#define MAIN         // we are the main program, we need to define this

#include <unistd.h>
#include "Server.h"
#include "mServer.h"
#include "aServer.h"
#include "log1.h"
#include "signal.h"
#include "Datahandler.h"
#include <sys/stat.h>
#include <string>
#include <thread>
#include <limits.h>
#include "pythonStructures.h"

using namespace libconfig;
        
//Handler for signals generated by the OS
void signalHandler(int signum)
{
    switch(signum)
    {
        case 2:     //SIGINT
            FILE_LOG(logINFO) << "System \"interrupt\" (SIGINT) signal received";
            FILE_LOG(logWARNING) << "Un-handled signal";
            break;
            
        case 6:     //SIGABRT
            FILE_LOG(logINFO) << "System \"abort\" (SIGABRT) signal received";
            FILE_LOG(logWARNING) << "Un-handled signal";
            break;
            
        case 8:     //SIGFPE
            FILE_LOG(logINFO) << "System \"floating-point arithmetic exception\" (SIGFPE) signal received";
            FILE_LOG(logWARNING) << "Un-handled signal";
            break;
            
        case 4:     //SIGILL
            FILE_LOG(logINFO) << "System \"illegal instruction\" (SIGILL) signal received";
            FILE_LOG(logWARNING) << "Un-handled signal";
            break;
            
        case 11:    //SIGSEGV
            FILE_LOG(logINFO) << "System \"segmentation violation\" (SIGSEGV) signal received";
            FILE_LOG(logWARNING) << "Un-handled signal";
            break;
            
        case 15:    //SIGTERM
            FILE_LOG(logINFO) << "System \"termination\" (SIGTERM) signal received";
            FILE_LOG(logWARNING) << "Un-handled signal";
            break;
            
        case 1:     //SIGHUP
            FILE_LOG(logINFO) << "System \"hangup\" (SIGHUP) signal received";
            FILE_LOG(logWARNING) << "Un-handled signal";
            break;
            
    }
    
    exit(0);
}

bool checkPath( const std::string& filepath ){
    
    char *file = new char[filepath.length()+1];
    strcpy( file, filepath.c_str() );
    struct stat buffer;
    if( stat( file, &buffer ) == 0 ){ delete file; return true; }
    else{ delete file; return false; }
}

std::string ensureConfig()
{
    std::string cwd( get_current_dir_name() );
    if( checkPath( "/etc/AnalyticsServer/AnalyticsServer.conf" ) )
        return "/etc/AnalyticsServer/AnalyticsServer.conf";
    else if ( checkPath(cwd+"/etc/AnalyticsServer.conf" ))
        return cwd+"/etc/AnalyticsServer.conf";
    else if( checkPath(cwd+"/AnalyticsServer.conf" ))
        return cwd+"/AnalyticsServer.conf";
    else {
        std::cout 
            << "Unable to access server configuration file.\n"
            << "No configuration file exists in the default locations."
            << std::endl;
        exit(0);
    }
}

bool is_number( const std::string& s ){
    return !s.empty() && std::find_if( s.begin(), s.end(), 
            [](char c) { return !std::isdigit( c ); }) == s.end();
}

int main(int argc, char *argv[])
{
    //Assign signal handler
    signal(SIGINT, signalHandler);
    signal(SIGABRT, signalHandler);
    signal(SIGFPE, signalHandler);
    signal(SIGILL, signalHandler);
    signal(SIGSEGV, signalHandler);
    signal(SIGTERM, signalHandler);
    signal(SIGHUP, signalHandler);
    
    std::string configFileAddress;
    
    int daemonToggle;
    int *runToggle = new int(1);
    
    int *logToggle = new int(0);
    std::string logLevel;
    std::string logLocation;
    
    int aPort, mPort;
 
    // Loop through each supplied argument
    for (int i=1; i < argc; ++i){
        std::string str_arg(argv[i]);
        
        // -h --help flag
        if(str_arg == "--help" || str_arg == "-h"){
            std::cout
                << "\nUsage: analytics_server [OPTION] [VALUE]... [SERVER CONFIG FILE]" << "\n\n"
                << "If no configuration file location is provided, these locations are checked:" << "\n"
                << "\t- /etc/AnalyticsServer/AnalyticsServer.conf" << "\n" 
                << "\t- ./AnalyticsServer.conf" << "\n"
                << "Otherwise Computation is terminated." << "\n\n"
                << "\n"
                << "  -d, --start_deamon         starts program as a deamon process sending std out" << "\n"
                << "                              to predetermined location in config." << "\n\n"
                << "  -t, --test_start           test correct server installation and configuration by" << "\n"
                << "                              running the server initialisation sequence only." << "\n\n"
                << "  -a, --analytics_port       specify the port on which the analytics server will" << "\n"
                << "                              accept service request commands." << "\n\n"
                << "  -m, --management_port      specify the port on which the analytics server will" << "\n"
		<< "                              accept management commands." << "\n\n"
                << "  -r, --report               Toggle debug mode so that logs are printed to terminal" << "\n"
                << "                              at a set debug level" << "\n\n"
                << "  -l, --log_location         specify the location where program logs are to be" << "\n"
                << "                              generated." << "\n"
                << "\n"
                << "Special notice - Starting the process in Daemon mode will cause the program to ignore" << "\n"
                << "the debug tag as output shall be printed to file. The testing mode will ignore the" << "\n"
                << "the log location tag as it will print to the terminal.\n"
            << std::endl; 
           
            return 0;
        }

        // Start Deamon Server
        if( str_arg == "-d" || str_arg == "--start_deamon"){
            daemonToggle = 1; 
            continue;
        }

        // Test Server
        if( str_arg == "-t" || str_arg == "--test_start"){
            *runToggle = 0;
            continue;
        }
        
        // -d debug mode
        if( str_arg == "--report" || str_arg == "-r" ){

            if( daemonToggle != 1 ){
                
                if( i == (argc - 1) ){
                    std::cout 
                        << "Log level is not specified with tag." 
                    << std::endl;
                    return 0;
                }
                
                if( argv[i+1] == FILELog::ToString( FILELog::FromString(argv[i+1]) ) ){
                    *logToggle = 1;
                    logLevel = argv[i+1];
                }
                else
                {
                    std::cout
                        << "That log level could not be identified."
                    << std::endl;
                    continue;
                }   
            }
            i++;
            continue;
        }
        
        if( str_arg == "--analytics_port" || str_arg == "-a" ){
            if( i != (argc - 1) ){
                if( is_number( argv[i+1]) ){
                    aPort = std::stoi( argv[i+1] );
                    i++;
                    continue;
                } else {
                    std::cout 
                        << "Analytics port either not given or"
                        << "not a number." 
                    << std::endl;
                    return 0;
                }   
            } else {
                std::cout << "Analytics port tag found without value" << std::endl;
                return 0;
            }
        }
        
        if( str_arg == "--management_port" || str_arg == "-m" ){    
            if( i != (argc - 1) ){
                if( is_number( argv[i+1]) ){
                    mPort = std::stoi( argv[i+1] );
                    i++;
                    continue;
                } else {
                    std::cout 
                        << "Management port either not given or"
                        << "not a number." 
                    << std::endl;
                    return 0;
                }
            } else {
                std::cout 
                    << "Management port tag found without value." 
                << std::endl;
                return 0;
            }
        }
        
        if( str_arg == "--log_location" || str_arg == "-l" ){
            if( i != (argc-1)){
                if( checkPath( argv[i+1] ) ){ logLocation = argv[i+1]; i++; }
                else {
                    std::cout 
                        << "Path to log location is invalid."
                    << std::endl;
                    return 0;
                }
            } else {
                std::cout
                    << "Log tag found without value set."
                << std::endl;
                return 0;
            }
            
        }
        
        //Only run if argument not caught above
        if(argv[i][0] == '-'){
            //Argument is an option flag but has not been caught above and therefore is not valid
            std::cout 
                    << "AnalyticsServer: invalid option: \'" << str_arg << "\'\n"
                    << "Try \'AnalyticsServer --help\' for more information."
            << std::endl;
            return 0;
        }
        
        if( i == (argc - 1) ){
            //Argument is the last in the list therefore Configuration address.
            if( str_arg.substr( 0 , 2 ) == "./" )
                str_arg = get_current_dir_name() + str_arg.substr(1);
            else if ( str_arg[0] != '/' ){
                str_arg = get_current_dir_name() + std::string("/") + str_arg;
            }
            
            if( checkPath( str_arg ) ){ //test if file exists
                configFileAddress = str_arg;
            } else {
                std::cout
                        << "Unable to access configuration file at: " << str_arg <<".\n"
                        << "File does not exist." << "\n"
                        << "Startup aborted."
                << std::endl;
                return 0;
            }
        }

    } //end looping through arguments
    
    // Look for config if non given.
    if( configFileAddress == "" ) configFileAddress = ensureConfig();
    if( daemonToggle ){ *logToggle = 0; logLevel.clear(); }
    if( !*runToggle ){ *logToggle = 1; logLevel = "DEBUG4"; }
    
    /*
    * ----------------------------------------------------------
    *                      Start Servers
    * ----------------------------------------------------------
    */
    
    int pid = 0;
    
    if ( daemonToggle ){
        pid = fork();
        if(pid < 0){
            FILE_LOG(logERROR) << "Daemonizing server process failed.";
            FILE_LOG(logERROR) << "Server startup aborted.";
            return -1;
        }
    }
    
    if ( pid != 0 )
    FILE_LOG(logINFO) << "Server startup underway - process id: " << pid <<".";
    else
    {
        // Start the Global python interpreter.
        pythonInitialise init;
        
        //Create the server object
        mServer ms( runToggle, logToggle, logLevel );     //Management Server
        aServer as( runToggle, logToggle );     //Analytics Server

        //Swap to standard logging module as server is now starting
        //N.B. logging is currently to the terminal
        FILE_LOG( logINFO ) << "Initialising Analytics Server...";

        FILE_LOG( logINFO ) << "Reading master configuration at:" << nli()
                            << configFileAddress
                            << ".";

        //Read the master config
        if (Datahandler::loadInConfig( configFileAddress, aPort, mPort, logLocation ) != 0){
           FILE_LOG( logERROR ) << "Error reading master configuration file";
           FILE_LOG( logERROR ) << "Startup aborted";
           return 0;
        }

        FILE_LOG( logINFO ) << "Initialising application pools for deployed services...";

        //Initialise the app pools.
        if ( ms.flushServiceDirectory() != 0 ){
           FILE_LOG( logERROR ) << "Error starting application pools";
           FILE_LOG( logERROR ) << "Startup aborted";
           return 0;
        };

        FILE_LOG( logINFO ) << "Binding to analytics server port...";
        
        int aSocket = as.initialiseSocket( Datahandler::getAnalytics() );
        if(!( aSocket > 0 )){
           FILE_LOG( logERROR ) << "Error binding to analytics socket";
           FILE_LOG( logERROR ) << "Startup aborted";
           return 0;
        }

        FILE_LOG( logINFO ) << "Binding to management server port...";

        int mSocket = ms.initialiseSocket( Datahandler::getManagement() );
        if( !( mSocket > 0)){
           FILE_LOG( logERROR ) << "Error binding to management socket";
           FILE_LOG( logERROR ) << "Startup aborted";
           return 0;
        }
        
        std::thread ms_thread ( &mServer::start, &ms );
        std::thread as_thread ( &aServer::start, &as );
        
        //block until threads completed
        ms_thread.join();
        as_thread.join();
        
        FILE_LOG( logINFO ) << "Cleaning up environment.";
        delete Datahandler::getInstance();
        FILE_LOG( logINFO  ) << "Process Exiting.";
    }
    return 0;
}